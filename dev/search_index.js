var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = FastLevenbergMarquardt","category":"page"},{"location":"#FastLevenbergMarquardt","page":"Home","title":"FastLevenbergMarquardt","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FastLevenbergMarquardt.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [FastLevenbergMarquardt]","category":"page"},{"location":"#FastLevenbergMarquardt.lmsolve","page":"Home","title":"FastLevenbergMarquardt.lmsolve","text":"lmsolve(\n    fun,\n    jac,\n    x0::StaticVector{N, <:AbstractFloat},\n    data = nothing,\n    lb::Union{Nothing, Real, AbstractVector{<:Real}} = nothing,\n    ub::Union{Nothing, Real, AbstractVector{<:Real}} = nothing;\n    kwargs...\n) -> x, F, info, iter, nfev, njev\n\nlmsolve!(\n    fun!,\n    jac!,\n    x0::AbstractVector{<:AbstractFloat},\n    m::Integer = length(x0),\n    data = nothing,\n    lb::Union{Nothing, Real, AbstractVector{<:Real}} = nothing,\n    ub::Union{Nothing, Real, AbstractVector{<:Real}} = nothing;\n    kwargs...,\n) -> x, F, info, iter, nfev, njev, LM, solver\n\nlmsolve!(\n    fun!,\n    jac!,\n    x0::AbstractVector{<:AbstractFloat},\n    f::AbstractVector{<:AbstractFloat},\n    J::AbstractMatrix{<:AbstractFloat},\n    data = nothing,\n    lb::Union{Nothing, Real, AbstractVector{<:Real}} = nothing,\n    ub::Union{Nothing, Real, AbstractVector{<:Real}} = nothing;\n    kwargs...,\n) -> x, F, info, iter, nfev, njev, LM, solver\n\nlmsolve!(\n    fun!,\n    jac!,\n    LM::LMWorkspace,\n    data = nothing,\n    lb::Union{Nothing, Real, AbstractVector{<:Real}} = nothing,\n    ub::Union{Nothing, Real, AbstractVector{<:Real}} = nothing;\n    kwargs...\n) -> x, F, info, iter, nfev, njev, LM, solver\n\nMinimize F(x) = ||f(x)||^2 using the Levenberg-Marquardt algorithm.\n\nArguments\n\nfun/fun!: function to be minimized ||f||^2, f = fun(x, data),   f = fun!(f, x, data)\njac/jac!: jacobian of f, J = jac(x, data), J = jac!(J, x, data)\nx0::AbstractVector{<:AbstractFloat}: initial guess\nm::Integer = length(x0): number of function values\ndata = nothing: data passed to fun/fun! and jac/jac!\nf::AbstractVector{<:AbstractFloat}: preallocated function vector\nJ::AbstractMatrix{<:AbstractFloat}: preallocated Jacobian matrix\nLM::LMWorkspace: preallocated workspace\nlb::Union{Nothing, Real, AbstractVector{<:Real}} = nothing: lower bounds   for x. Vectors must have same length as x\nub::Union{Nothing, Real, AbstractVector{<:Real}} = nothing: upper bounds   for x. Vectors must have same length as x\n\nKeywords\n\nsolver::Union{Nothing, Symbol} = nothing: linear solver for lmsolve!       (lmsolve always uses Cholesky factorization)\nnothing: QR for dense Jacobian, Cholesky for sparse Jacobian\n:cholesky: Cholesky factorization\n:qr: QR factorization\nftol::Real = eps(eltype(x)): relative tolerance for function:   both actual and predicted reductions are less than ftol\nxtol::Real = 1e-10: relative tolerance for change in x:   all(abs(x - xk) < xtol * (xtol + abs(x)))\ngtol::Real = eps(eltype(x)): tolerance for gradient:   norm(g, Inf) < gtol\nmaxit::Integer = 1000: maximum number of iterations\nfactor::Real = 1e-6: initial factor for damping\nfactoraccept::Real = 13: factor for decreasing damping on good step\nfactorreject::Real = 3: factor for increasing damping on bad step\nfactorupdate::Symbol = :marquardt: factor update method   ∈ (:marquardt, :nielsen)\nminscale::Real = 1e-12: diagonal scaling lower bound\nmaxscale::Real = 1e16: diagonal scaling upper bound\nminfactor::Real = 1e-28: damping factor lower bound\nmaxfactor::Real = 1e32: damping factor upper bound\n\nReturns\n\nx/LM.x: solution\nF: final objective\ninfo::Int: convergence status\n1: both actual and predicted reductions are less than ftol\n2: relative difference between two consecutive iterates is less than xtol\n3: inf norm of the gradient is less than gtol\n-1: maxit reached\niter::Int: number of iterations\nnfev::Int: number of function evaluations\nnjev::Int: number of Jacobian evaluations\nLM::LMWorkspace: workspace\nsolver::AbstractSolver: solver\n\nNotes\n\nIn the returned LMWorkspace, only LM.x and LM.f are guaranteed to be updated. That is, LM.J might not be the Jacobian at the returned x.\n\n\n\n\n\n","category":"function"},{"location":"#FastLevenbergMarquardt.lmsolve!","page":"Home","title":"FastLevenbergMarquardt.lmsolve!","text":"lmsolve(\n    fun,\n    jac,\n    x0::StaticVector{N, <:AbstractFloat},\n    data = nothing,\n    lb::Union{Nothing, Real, AbstractVector{<:Real}} = nothing,\n    ub::Union{Nothing, Real, AbstractVector{<:Real}} = nothing;\n    kwargs...\n) -> x, F, info, iter, nfev, njev\n\nlmsolve!(\n    fun!,\n    jac!,\n    x0::AbstractVector{<:AbstractFloat},\n    m::Integer = length(x0),\n    data = nothing,\n    lb::Union{Nothing, Real, AbstractVector{<:Real}} = nothing,\n    ub::Union{Nothing, Real, AbstractVector{<:Real}} = nothing;\n    kwargs...,\n) -> x, F, info, iter, nfev, njev, LM, solver\n\nlmsolve!(\n    fun!,\n    jac!,\n    x0::AbstractVector{<:AbstractFloat},\n    f::AbstractVector{<:AbstractFloat},\n    J::AbstractMatrix{<:AbstractFloat},\n    data = nothing,\n    lb::Union{Nothing, Real, AbstractVector{<:Real}} = nothing,\n    ub::Union{Nothing, Real, AbstractVector{<:Real}} = nothing;\n    kwargs...,\n) -> x, F, info, iter, nfev, njev, LM, solver\n\nlmsolve!(\n    fun!,\n    jac!,\n    LM::LMWorkspace,\n    data = nothing,\n    lb::Union{Nothing, Real, AbstractVector{<:Real}} = nothing,\n    ub::Union{Nothing, Real, AbstractVector{<:Real}} = nothing;\n    kwargs...\n) -> x, F, info, iter, nfev, njev, LM, solver\n\nMinimize F(x) = ||f(x)||^2 using the Levenberg-Marquardt algorithm.\n\nArguments\n\nfun/fun!: function to be minimized ||f||^2, f = fun(x, data),   f = fun!(f, x, data)\njac/jac!: jacobian of f, J = jac(x, data), J = jac!(J, x, data)\nx0::AbstractVector{<:AbstractFloat}: initial guess\nm::Integer = length(x0): number of function values\ndata = nothing: data passed to fun/fun! and jac/jac!\nf::AbstractVector{<:AbstractFloat}: preallocated function vector\nJ::AbstractMatrix{<:AbstractFloat}: preallocated Jacobian matrix\nLM::LMWorkspace: preallocated workspace\nlb::Union{Nothing, Real, AbstractVector{<:Real}} = nothing: lower bounds   for x. Vectors must have same length as x\nub::Union{Nothing, Real, AbstractVector{<:Real}} = nothing: upper bounds   for x. Vectors must have same length as x\n\nKeywords\n\nsolver::Union{Nothing, Symbol} = nothing: linear solver for lmsolve!       (lmsolve always uses Cholesky factorization)\nnothing: QR for dense Jacobian, Cholesky for sparse Jacobian\n:cholesky: Cholesky factorization\n:qr: QR factorization\nftol::Real = eps(eltype(x)): relative tolerance for function:   both actual and predicted reductions are less than ftol\nxtol::Real = 1e-10: relative tolerance for change in x:   all(abs(x - xk) < xtol * (xtol + abs(x)))\ngtol::Real = eps(eltype(x)): tolerance for gradient:   norm(g, Inf) < gtol\nmaxit::Integer = 1000: maximum number of iterations\nfactor::Real = 1e-6: initial factor for damping\nfactoraccept::Real = 13: factor for decreasing damping on good step\nfactorreject::Real = 3: factor for increasing damping on bad step\nfactorupdate::Symbol = :marquardt: factor update method   ∈ (:marquardt, :nielsen)\nminscale::Real = 1e-12: diagonal scaling lower bound\nmaxscale::Real = 1e16: diagonal scaling upper bound\nminfactor::Real = 1e-28: damping factor lower bound\nmaxfactor::Real = 1e32: damping factor upper bound\n\nReturns\n\nx/LM.x: solution\nF: final objective\ninfo::Int: convergence status\n1: both actual and predicted reductions are less than ftol\n2: relative difference between two consecutive iterates is less than xtol\n3: inf norm of the gradient is less than gtol\n-1: maxit reached\niter::Int: number of iterations\nnfev::Int: number of function evaluations\nnjev::Int: number of Jacobian evaluations\nLM::LMWorkspace: workspace\nsolver::AbstractSolver: solver\n\nNotes\n\nIn the returned LMWorkspace, only LM.x and LM.f are guaranteed to be updated. That is, LM.J might not be the Jacobian at the returned x.\n\n\n\n\n\n","category":"function"}]
}
